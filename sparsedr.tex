%%%% ijcai26.tex

\typeout{IJCAI--ECAI 26 Instructions for Authors}

% These are the instructions for authors for IJCAI--ECAI 26.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

% The file ijcai26.sty is a copy from ijcai22.sty
% The file ijcai22.sty is NOT the same as previous years'
\usepackage{ijcai26}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[switch]{lineno}

% Comment out this line in the camera-ready submission
\linenumbers

\urlstyle{same}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.


% PDF Info Is REQUIRED.

% Please leave this \pdfinfo block untouched both for the submission and
% Camera Ready Copy. Do not include Title and Author information in the pdfinfo section
\pdfinfo{
/TemplateVersion (IJCAI.2026.0)
}

\title{SparseDR: Differentiable Rendering of Sparse Signed Distance Fields}

% Single author syntax
% \author{
%     Author Name
%     \affiliations
%     Affiliation
%     \emails
%     email@example.com
% }

% Multiple author syntax (remove the single-author syntax above and the \iffalse ... \fi here)
% \iffalse
\author{
First Author$^1$
\and
Second Author$^2$\and
Third Author$^{2,3}$\And
Fourth Author$^4$\\
\affiliations
$^1$First Affiliation\\
$^2$Second Affiliation\\
$^3$Third Affiliation\\
$^4$Fourth Affiliation\\
\emails % usually included
\{first, second\}@example.com,
third@other.example.com,
fourth@example.com
}
% \fi

\begin{document}

\maketitle

\begin{abstract}
    We present SparseDR, a differentiable rendering implementation designed for
    sparse representations based on Signed Distance Fields (SDF). We leverage the
    Sparse Brick Set (SBS) representation and propose an adaptation of redistancing and
    regularization of the SDF defined on SBS. This enables our method to surpass
    existing differentiable rendering implementations in accuracy at limited memory
    budgets by increasing the effective resolution of the SDF representation.

\end{abstract}

\section{Introduction}

    Signed distance functions (SDFs) provide a continuous, implicit representation of
    geometry, defining the shortest Euclidean distance from any point in space to the
    nearest surface, with the sign indicating interior or exterior regions. This enables
    gradient-based optimization by supporting differentiable rendering, where ray marching
    samples distances to compute density and color, facilitating inverse rendering tasks
    such as shape and material recovery from images.
    
    SDF-based differentiable rendering produces high-fidelity reconstructions with smooth
    surfaces and topological consistency, outperforming many existing methods in handling
    complex topologies. Unfortunately, existing SDF-based differentiable rendering implementations
    are constrained in reconstruction accuracy due to high memory consumption and
    substantial computational demands. Our work proposes a solution to this problem,
    alleviating limitations through better data structures and sampling techniques: 

    \begin{itemize}
    	\item We propose an adaptation of SDF-based differentiable rendering to a sparse
              data structure, which increases the effective resolution of the SDF representation
              and thereby improves the surface reconstruction accuracy.
    	\item We provide two novel algorithms of redistancing: a full version for SBS in general
              and its accelerated version specifically for the differentiable rendering of SBS.
    \end{itemize}


\section{Related Work}
    
    \cite{DRSDF22} introduces differentiable rendering operating directly on an SDF
    representation. The authors modified sphere tracing so that, in addition to computing
    the surface intersection, it evaluates a special reparameterization of rays, enabling
    correct gradients with respect to shape parameters, including the visibility
    contribution of individual surface regions. This work also first proposed the use
    of a \textit{redistancing} --- a process of recomputing values on a grid such that
    all grid cells store correct distances to the surface. In differentiable rendering
    this recomputation is required because, after an optimization step and updating the
    distances at grid nodes, the grid no longer strictly represents an SDF. \cite{DRSDF24}
    exploits properties of distance functions and estimate the boundary integral by an
    integral over a relaxed boundary, i.e., a thin band around the object silhouette.
    \cite{ManyWorld25} propose for computing gradients in the presence of multiple
    surfaces along a ray path: instead of locally differentiating a single surface,
    the authors consider a volumetric, non-local perturbation of the surface.
    
    All of the above methods represent the distance function volumetrically on a regular
    grid, which leads to three fundamental issues: (1) significant memory consumption,
    especially when using automatic differentiation frameworks such as DrJit \cite{drjit}
    or PyTorch \cite{pytorch}; (2) slow ray–surface intersection based on sphere tracing;
    (3) an expensive redistancing algorithm that propagates modified SDF values across
    the entire grid.
    
    Hash-table-based methods such as InstantNGP \cite{InstantNGP} could mitigate the
    first issue, but by themselves cannot address the second and third. The key
    difficulty is that the data structure used to store the SDF directly constrains
    how differentiable ray–surface intersections are computed and how redistancing is
    performed, and implementing redistancing on hash tables is, in our view, highly
    nontrivial. Our work shows how these three components -- data structure, ray intersection,
    and redistancing -- can be joined together in an efficient manner.


\section{Implementation Details}
\begin{figure}
    \centering
    \includegraphics[width=\columnwidth,keepaspectratio]{figures/header.eps}
    \caption{Comparison of SparseDR algorithm with the baseline.
             The baseline (on the left) uses dense SDF grid to represent the surface, and sphere
             tracing for ray-scene intersection. SparseDR (on the right) uses Sparse Brick Set,
             each brick stores small SDF grid, and a ray intersects each brick on its way
             until it hits the surface. }
    \label{fig:header}
\end{figure}

    To store the surface, SparseDR uses the Sparse Brick Set (SBS) proposed in \cite{soderlund2022ray},
    which is a hybrid of hierarchical and regular representations, see Figure \ref{fig:header}. The entire scene is
    encoded as a BVH or an octree, while its leaves store small regular grids, for
    example 4x4x4 voxels (5x5x5 distances). For gradient computation, we adapt the relaxed boundary method from
    \cite{DRSDF24}, which we refer to as our baseline.
    At the beginning of the optimization process, the distance function is initialized with
    a sphere defined on a low-resolution grid (32x32x32). At each iteration, we estimate
    the gradient and update the distance values using a gradient descent step,
    followed by a regularization and accelerated redistancing (see Figure \ref{fig:redist}).
    On every iteration when upsampling is required, which is defined by the user,
    three steps are executed: sparsification step, full redistancing and upsampling.
    Sparsification and full redistancing are also applied before the resulting model is saved.

\textbf{Gradient evaluation.}
    The key distinction of the method underlying SparseDR lies in the transition from an
    SDF grid to a sparse brick set. In our case, each brick has a fixed size of 4×4×4 voxels.
    For the SBS, a BVH tree is constructed, with each leaf node storing a single brick.
    In addition to sphere tracing, the Newton method \cite{soderlund2022ray} for ray–SDF intersection has been
    implemented. It is specifically designed to find intersections inside
    the voxel. A ray first traverses the BVH; if an intersection with a leaf node is found,
    it then intersects the voxels of the brick. The ray traverses each brick along
    its path until it hits the surface or there are no bricks left.

    The Newton method was modified to search for relaxed
    boundary points. According to \cite{DRSDF24}, a point belongs to the relaxed boundary
    if the SDF value at that point is below a certain threshold, which we refer to as the relaxed epsilon,
    and the SDF derivative along the ray reaches its local minimum. The Newton
    method is based on the fact that inside a voxel, the SDF along the ray can be
    represented as a cubic polynomial. Thus, within the voxel, a potential relaxed boundary
    point is found as the root of a quadratic equation, after which the SDF value at
    the point is checked to be less than the relaxed epsilon. The case when the local
    minimum occurs on the boundary between voxels or bricks is handled separately.

    SparseDR is implemented in C++ and Vulkan and does not use automatic differentiation.
    The chain of computations that was differentiated is as follows: MSE loss -- pixel color
    (an average of sample colors) -- sample color (when it hits the surface: trilinear
    interpolation of distances in the voxel) -- distances.
    Gradients are accumulated in a float array whose size equals the number of updated
    distances. In the shader, when computing the color of a pixel for 16 samples,
    information about the voxels hit by the samples is stored; after every 16 samples
    (or after the last one), the gradients are added to the array.
    SparseDR optionally uses an additional shader that samples only pixels containing
    boundaries and evaluates only the boundary integral, without the need for color
    computation. This adaptive boundary sampling allows cheaper samples and yields more
    accurate gradients for smaller relaxed epsilon values, thereby reducing bias.

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth,keepaspectratio]{figures/redistancing.eps}
    \caption{Comparison of the redistancing algorithm on grid (on the left) with the accelerated version
             (on the right) with SBS bricks 3x3 distances in size.
             The dots represent the distance values. Red and blue dots are the distances outside and inside the
             object respectively. Strip line represents the surface, set by distances colored
             white. Arrows show the order of updating the values. Bricks without surface (grey) are ignored by
             accelerated redistancing. }
    \label{fig:redist}
\end{figure}

\textbf{Redistancing.}
    For differentiable rendering of SBS in SparseDR, two versions of redistancing have
    been implemented. The first, full version, is an adaptation of the parallel fast sweeping
    method \cite{DETRIXHE201346} for SBS, which is used to acquire the correct SDF. It addresses the problem of
    distance updates across empty space between bricks by additionally using extrapolation
    between brick faces. For each face of a brick without a direct neighbor, the nearest
    neighbor bricks are found, and one of their faces is selected for extrapolation. These
    neighbors are determined once, and after each fast sweeping step, values are extrapolated
    considering the grid spacing. From the extrapolated and previous values, the one with
    the smallest absolute value is chosen. To propagate the updated distances, the fast
    sweeping method is always applied as the final step of this algorithm.

    However, using SBS instead of a grid and Newton’s method for intersection enables certain
    optimizations to the redistancing algorithm for the needs of differentiable rendering.
    First, it ignores the bricks without surface, and second, the value updates are localized
    within the bricks and not propagated between them. This accelerated version neither
    degrades reconstruction quality nor affects convergence to the reference.

    The first version outputs correct sparse SDF, so it is used in SparseDR before
    upsampling and saving the result of reconstruction. The second version is faster
    while giving the same result, so it is applied on each iteration.


\textbf{Sparsification and Upsampling.}
    The sparsification step is performed before upsampling. During this stage, all bricks
    containing the surface are preserved, as well as all bricks within a radius of 1
    voxel from them, including diagonal neighbors. If any of the adjacent bricks are
    missing, they are added at this stage. This is necessary in cases where the
    reconstructed object contains fine details, so that the bricks where these details'
    reconstruction should reside would otherwise be absent. Thus, this step not only
    contributes to reducing the model size, but also eliminates a potential limitation
    compared to the baseline method.
    After the sparsification step, the full version of redistancing is applied to
    recompute all distances before upsampling or saving the resulting SBS, ensuring
    that the model represents a valid SDF.
    The upsampling step doubles the resolution of the remaining bricks, generating eight
    new bricks from each original one. The new distance values are computed using trilinear
    interpolation.


\section{Experiments}

    Experiments with the baseline method were conducted using the official implementation from \cite{DRSDF24Repo}.
    The baseline method employed the hyperparameters
    specified in the paper \cite{DRSDF24}, while the remaining parameters were taken from
    the configuration file “turbo.json”. The only modifications concerned the number of
    viewpoints, the batch size, and the upsampling iterations. For
    consistency across experiments, an identical lighting setup was used: two directional
    light sources with directions $(1,1,1)$ and $(-1,-1,-1)$, along with ambient light.
    The experiments were carried out on six models. Reconstruction used 16 viewpoints
    uniformly distributed over a sphere around the scene, generated by the algorithm
    from \cite{DRSDF24Repo}. The batch size is 4 viewpoints, image resolution is 1024×1024.
    The full optimization process comprised 1000 steps, with upsampling applied at steps
    200, 400, 600, 700, 800, and 900. Computations were performed on an AMD Ryzen 9 7950X CPU
    and an NVIDIA GeForce RTX 4090 GPU.

    % На рис. N показано среднее по всем моделям время реконструкции for each stage between upsampling
    % steps для SparseDR и базового метода. Они обозначены размером SDF grid в вокселях соответствующего уровня
    % детализации. Batch rendering is a consecutive отрисовка всех ракурсов на текущем
    % батче.

    % На рис. N+1 показано среднее по ракурсам качество реконструкции для SparseDR и
    % базового метода.

    % И наконец, на рис. N+2 показан размер моделей для SparseDR и базового метода,
    % полученных после каждого upsampling step. Для базового метода указан размер of grid,
    % для SparseDR -- the size of SBS and the size of its BVH. Результаты показывают,
    % что рост размера SBS на порядок меньше, чем у SDF grid.

\section{Conclusion}

    In this work we present SparseDR, a system for 3D reconstruction based on the method
    of differentiable rendering for a sparse SDF representation. Using [reference] as a
    baseline, we leverage the advantages of SBS and modify all stages of the algorithm.
    As a result, SparseDR achieves performance and reconstruction quality comparable to
    the original approach while reducing memory consumption by an order of magnitude.
    Future work will focus on upgrading SparseDR to a full-fledged path tracer and
    addressing the challenges that complicate the practical use of differentiable rendering,
    in particular the need for precise camera parameter information.


%% The file named.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{named}
\bibliography{sparsedr}

\end{document}

