%%%% ijcai26.tex

\typeout{IJCAI--ECAI 26 Instructions for Authors}

% These are the instructions for authors for IJCAI--ECAI 26.

\documentclass{article}
\pdfpagewidth=8.5in
\pdfpageheight=11in

% The file ijcai26.sty is a copy from ijcai22.sty
% The file ijcai22.sty is NOT the same as previous years'
\usepackage{ijcai26}

% Use the postscript times font!
\usepackage{times}
\usepackage{soul}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[small]{caption}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[switch]{lineno}

% Comment out this line in the camera-ready submission
\linenumbers

\urlstyle{same}

% the following package is optional:
%\usepackage{latexsym}

% See https://www.overleaf.com/learn/latex/theorems_and_proofs
% for a nice explanation of how to define new theorems, but keep
% in mind that the amsthm package is already included in this
% template and that you must *not* alter the styling.
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.


% PDF Info Is REQUIRED.

% Please leave this \pdfinfo block untouched both for the submission and
% Camera Ready Copy. Do not include Title and Author information in the pdfinfo section
\pdfinfo{
/TemplateVersion (IJCAI.2026.0)
}

\title{SparseDR: Differentiable Rendering of Sparse Signed Distance Fields}

% Single author syntax
% \author{
%     Author Name
%     \affiliations
%     Affiliation
%     \emails
%     email@example.com
% }

% Multiple author syntax (remove the single-author syntax above and the \iffalse ... \fi here)
% \iffalse
\author{
First Author$^1$
\and
Second Author$^2$\and
Third Author$^{2,3}$\And
Fourth Author$^4$\\
\affiliations
$^1$First Affiliation\\
$^2$Second Affiliation\\
$^3$Third Affiliation\\
$^4$Fourth Affiliation\\
\emails % usually included
\{first, second\}@example.com,
third@other.example.com,
fourth@example.com
}
% \fi

\begin{document}

\maketitle

\begin{abstract}
    % За последнее десятилетие задача 3D реконструкции получила новый способ решения:
    % дифференцируемый рендеринг -- мощный инструмент, в рамках которого было предложено большое разнообразие
    % методов. Одна группа методов направлена на восстановление объектов, представленных
    % signed distance field grids, в рамках физически-обоснованного рендеринга. Signed
    % distance fields хорошо подходят для реконструкции поверхности, but the use of the dense grids leads to
    % быстрый рост потребляемой памяти при восстановлении моделей
    % with fine details. This work introduces SparseDR, реализация дифференцируемого рендеринга for
    % sparse representations based on signed distance fields. Благодаря предлагаемому
    % методу, лежащему в основе системы, мы получаем существенное сокращение используемой
    % памяти без потерь в точности и скорости реконструкции, что демонстрируем на
    % примерах реконструкции геометрии.

    We present SparseDR, a differentiable rendering implementation designed for
    sparse representations based on Signed Distance Fields (SDF). We leverage the
    Sparse Brick Set (SBS) representation and propose an adaptation of redistancing and
    regularization of the SDF defined on SBS. This enables our method to surpass
    existing differentiable rendering implementations in accuracy at limited memory
    budgets by increasing the effective resolution of the SDF representation.

\end{abstract}

\section{Introduction}

\begin{figure*}[h!]
    \centering
    \includegraphics[width=\textwidth,keepaspectratio]{figures/header.eps}
    \caption{Comparison of SparseDR algorithm (on the right) with the baseline.
             The key differences are using sparse SDF representation, SBS, and
             intersecting voxels along the ray instead of sphere tracing.}
    \label{fig:header}
\end{figure*}

    Signed distance functions (SDFs) provide a continuous, implicit representation of
    geometry, defining the shortest Euclidean distance from any point in space to the
    nearest surface, with the sign indicating interior or exterior regions. This enables
    gradient-based optimization by supporting differentiable rendering, where ray marching
    samples distances to compute density and color, facilitating inverse rendering tasks
    such as shape and material recovery from images.
    
    SDF-based differentiable rendering produces high-fidelity reconstructions with smooth
    surfaces and topological consistency, outperforming many existing methods in handling
    complex topologies. Unfortunately, existing SDF-based differentiable rendering implementations
    are constrained in reconstruction accuracy due to high memory consumption and
    substantial computational demands. Our work proposes a solution to this problem,
    alleviating limitations through better data structures and sampling techniques: 

    \begin{itemize}
    	\item We propose an adaptation of SDF-based differentiable rendering to a sparse
              data structure, which increases the effective resolution of the SDF representation
              and thereby improves the surface reconstruction accuracy.
    	\item We provide two novel algorithms of redistancing: a full version for SBS in general
              and its accelerated version specifically for the differentiable rendering of SBS.
    \end{itemize}

    %%% 3D object reconstruction as (something else and then) Inverse rendering.
    % Задача трёхмерной реконструкции -- получение информации об объекте реального
    % мира, в частности его форме. (TODO: про 3д реконструкцию + подводка к обратному рендерингу)

    % В рамках компьютерного зрения и графики ещё в конце XX века [ссылка] была сформулирована
    % задача обратного рендеринга. Если традиционный, прямой рендеринг позволяет получить
    % 2D изображение из 3D сцены, то обратный рендеринг подразумевает восстановление
    % параметров исходной сцены по её изображениям. Таким образом, задача обратного рендеринга
    % включает в себя трёхмерную реконструкцию.

    %%% Inverse rendering to Differentiable rendering.
    % В последнее десятилетие для решения задачи обратного рендеринга активно
    % используется дифференцируемый рендеринг -- метод, восстанавливающий объекты
    % по изображениям с использованием градиентных методов оптимизации. Существует
    % большое число разнообразных методов дифференцируемого рендеринга. Между собой
    % они различаются, в первую очередь, тем, какое представление используется в процессе
    % оптимизации: нейронные SDF [NeuralAngelo+], NeRF [ссылки], 3DGS [ссылки] (TODO: ещё что-нибудь).

    %%% DR methods for physically-based rendering. Tell a bit about meshes and Nicolet article, then about two nonNN methods (2022,2024).
    % В 2018 году появился метод edge sampling [ссылка], впервые позволивший получить
    % аналитические производные по параметрам геометрии, в частности меша, в физически-обоснованном
    % рендеринге. В этих условиях цвет пикселя представляет собой интеграл. При дифференцировании
    % по параметрам, задающим форму объекта, подынтегральное выражение терпит разрывы,
    % положение которых зависит от этих параметров. Для корректного расчёта градиентов
    % требуется оценить интеграл по этим разрывам, названный граничным интегралом. В edge
    % sampling предлагалось явно семплировать граничный интеграл, что требовало нахождения
    % всех граней, образующих силуэт объекта. В 2019
    % и 2020 годах появились два связанных между собой метода, которые избавлялись от
    % необходимости явного семплирования границ объекта при оценке производных. Первый
    % подход, репараметризация [ссылка], предлагал замену переменных, которая локально
    % учитывала разрывы, что позволяло уйти от оценки граничного интеграла вовсе. Метод
    % 2020 года, warped area sampling (WAS) [ссылка], строго показал, что граничный
    % интеграл в формуле производной возникает согласно транспортной теореме Рейнольдса,
    % и предложил продлить область определения граничного интеграла на пространство с
    % помощью теоремы Остроградского-Гаусса. Для этого перехода строится специальное 
    % векторное поле.

    % Три подхода к дифференцируемому рендерингу, описанные выше, использовали меши в практической 
    % реализации. Однако, меши, с точки зрения задачи реконструкции поверхности, имеют ряд фундаментальных 
    % проблем, которые делают их использование нежелательным. Их недостатки хорошо описаны и 
    % проиллюстрированы в работе 2021 года [ссылка]. Фундаментальной проблемой мешей является 
    % невозможность менять топологию объекта (род поверхности), также во время оптимизации могут возникать 
    % необратимые самопересечения и неоптимальные распределения примитивов, из-за чего в местах, требующих 
    % высокой детализации, нет достаточного числа примитивов для их представления. Модификации, 
    % представленные в работе, частично решают две последние проблемы, но
    % ограничение на топологию мешает свободному применению мешей для оптимизации.

    % Следом появилось несколько методов, также применимых в физически-обоснованном
    % рендеринге, которые использовали SDF grids в качестве оптимизируемого представления.
    % В 2022 году к SDF впервые применили репараметризацию [ссылка]. В этой работе было
    % предложено использовать алгоритм редистансинга. Редистансинг – задача пересчёта
    % значений сетки, чтобы её вершины содержали корректные расстояния до поверхности. В
    % дифференцируемом рендеринге пересчёт нужен, поскольку после шага оптимизации и 
    % обновления расстояний в узлах сетки она, строго говоря, уже не является SDF. Наконец,
    % метод 2024 года [ссылка] использует свойства функций расстояния и
    % оценивает граничный интеграл интегралом по релаксированной границе – тонкой линии
    % вокруг силуэта объекта.

    % При использовании SDF grid повышение детализации модели для более точной реконструкции поверхности
    % достигается путём апсемплинга всей сетки, что приводит к быстрому росту размера модели.
    % При этом для представления самой поверхности используется лишь небольшая часть вокселей,
    % и потребление памяти можно существенно снизить, если хранить только их. Статья [ссылка]
    % описывает несколько вариантов основанных на SDF разреженных представлений, в частности sparse brick set.
    % Данное представление представляет собой a sparse set of bricks -- small non-intersecting SDF grids.
    % Каждый такой кирпич хранится в листовом узле дерева BVH. Также в статье предлагаются
    % новые алгоритмы для пересечения луча с вокселем: метод Ньютона и аналитический метод.
    % Оба основаны на факте, что внутри вокселя, в случае трилинейной интерполяции, функция
    % расстояния вдоль луча представима кубическим полиномом. Отличие между ними заключается в
    % поиске корней этого полинома: аналитическом расчёте или же нескольких шагах метода Ньютона.

    %%% This method combines the idea of a relaxed boundary with the sparse SDF representation from [link].
    % В данной работе представлена система SparseDR. Её принцип работы основан на методе
    % дифференцируемого рендеринга SDF, сочетающем идею оценки граничного интеграла
    % из [ссылка] с SBS. Для пересечения луча со сценой используется метод Ньютона, адаптированный
    % под поиск точек релаксированной границы. Реализованы две версии редистансинга: разреженная
    % версия fast sweeping метода и приближённая ускоренная версия, а также разреженные версии
    % остальных этапов алгоритма. Добавлен sparsification step, отвечающий за удаление и
    % добавление of bricks. В результате SparseDR способна восстанавливать модели со
    % скоростью и точностью not inferior to the baseline method при существенном
    % сокращении потребляемой памяти.

\section{Related Work}
    
    \cite{DRSDF22} introduces differentiable rendering operating directly on an SDF
    representation. The authors modified sphere tracing so that, in addition to computing
    the surface intersection, it evaluates a special reparameterization of rays, enabling
    correct gradients with respect to shape parameters, including the visibility
    contribution of individual surface regions. This work also first proposed the use
    of a \textit{redistancing} --- a process of recomputing values on a grid such that
    all grid cells store correct distances to the surface. In differentiable rendering
    this recomputation is required because, after an optimization step and updating the
    distances at grid nodes, the grid no longer strictly represents an SDF. \cite{DRSDF24}
    exploits properties of distance functions and estimate the boundary integral by an
    integral over a relaxed boundary, i.e., a thin band around the object silhouette.
    \cite{ManyWorld25} propose for computing gradients in the presence of multiple
    surfaces along a ray path: instead of locally differentiating a single surface,
    the authors consider a volumetric, non-local perturbation of the surface.
    
    All of the above methods represent the distance function volumetrically on a regular
    grid, which leads to three fundamental issues: (1) significant memory consumption,
    especially when using automatic differentiation frameworks such as DrJit \cite{drjit}
    or PyTorch \cite{pytorch}; (2) slow ray–surface intersection based on sphere tracing;
    (3) an expensive redistancing algorithm that propagates modified SDF values across
    the entire grid.
    
    Hash-table-based methods such as InstantNGP \cite{InstantNGP} could mitigate the
    first issue, but by themselves cannot address the second and third. The key
    difficulty is that the data structure used to store the SDF directly constrains
    how differentiable ray–surface intersections are computed and how redistancing is
    performed, and implementing redistancing on hash tables is, in our view, highly
    nontrivial. Our work shows how these three components -- data structure, ray intersection,
    and redistancing -- can be joined together in an efficient manner.


\section{System Implementation}
    %%% Describe architecture -- components (their algorithms).
    % TODO: привести два алгоритма. Первый (внешний) показывает итерации по пресетам, между
    % которыми происходит разрежение и апсемплинг. Второй (внутренний) вызывается внутри
    % первого и содержит итерации дифф рендеринга. ПОСЛЕ попробовать показать, какие его
    % шаги новые, какие претерпели изменения, а какие остались нетронутыми.

    % Core differentiable rendering algorithm представляет собой
    % метод обучения с учителем, в котором на каждой итерации происходит отрисовка сцены с
    % ракурса, соответствующего одному из референсных изображений, после чего считается
    % функция потерь (MSE) между двумя рендерами и backpropagates к параметрам сцены.
    % Для корректного расчёта производных по дистанциям, следуя транспортной теореме Рейнольдса,
    % оценивается внутренний и граничный интеграл. Для оценки последнего был реализован метод
    % релаксированной границы из работы (ссылка), которая также является для нас базовой.
    % Мы также применяем Laplace filter и редистансинг для более стабильной реконструкции.

    % На рис. таком-то (псевдокодом) показан алгоритм работы SparseDR. В начале процесса оптимизации
    % SBS хранит все брики, составляя грид размером 32x32x32 voxels, так как на этом этапе the grid itself небольшой,
    % а поверхность объекта претерпевает наибольшие изменения. Затем, during the sparsification step сохраняются только
    % брики, которые содержат поверхность, и их ближайшие соседи.

    To store the surface, SparseDR uses the Sparse Brick Set (SBS) proposed in \cite{soderlund2022ray},
    which is a hybrid of hierarchical and regular representations, see Figure \ref{fig:header}. The entire scene is
    encoded as a BVH or an octree, while its leaves store small regular grids, for
    example 4x4x4. For gradient computation, we adapt the relaxed boundary method from
    \cite{DRSDF24}, which we refer to as our baseline.
    At the beginning of the optimization process, the distance function is initialized with
    a sphere defined on a low-resolution grid (32x32x32). At each iteration, we estimate
    the gradient and update the distance values using a gradient descent step,
    followed by a regularization and accelerated redistancing (see Figure \ref{fig:redist}).
    On every iteration when upsampling is required, which is defined by the user,
    three steps are executed: sparsification step, full redistancing and upsampling.
    Sparsification and full redistancing are also applied before the resulting model is saved.
    % This relies on the reasonable assumption that updating only the bricks containing the
    % surface allows to aquire correct relaxed boundary points, thus local redistancing is
    % sufficient for the needs of differentiable rendering. Still, the other distances must
    % be updated for SBS to represent a correct SDF. Additionally, during the sparsification
    % step SBS can aquire new bricks, which also require redistancing for the new distanaces.
    % Because of that, each time before the upsampling and at the end of optimization
    % we apply the sparsification step and redistance the entire SBS.

\subsection{Gradient evaluation}

    % Ключевым отличием метода в основе SparseDR является переход от SDF grid к
    % sparse brick set. В нашем случае, размер каждого брика фиксирован
    % и равен 4x4x4 voxels. Для SBS строится BVH tree, каждый листовой узел которого хранит один brick.
    % Помимо sphere tracing [link], были реализованы альтернативные методы
    % of ray-SDF intersection [link]: Newton and analytic, специально созданные для
    % поиска пересечения inside the voxel. Теперь луч traverses the BVH first, и, если найдено
    % пересечение с листовым узлом, intersects the voxels of the brick. Луч проходит каждый
    % брик на своём пути, до первого пересечения с поверхностью.

    % Alternative ray-SDF intersection methods also support поиск точек релаксированной
    % границы. Из [ссылка], точка принадлежит релаксированной границе, если SDF в этой
    % точке меньше некоторого порога, названного relaxed epsilon, а производная SDF along
    % the ray reaches its local minimum.
    % Newton and analytic methods are based on the fact that inside the voxel, SDF along
    % the ray представима в виде полинома третьей степени. Таким образом, внутри вокселя
    % потенциальная точка релаксированной границы может быть найдена как корень квадратного уравнения,
    % после чего нужно лишь проверить, что значение SDF в ней меньше relaxed epsilon. Случай,
    % когда локальный минимум достигается на границе вокселей или бриков, обрабатывается отдельно.

    % SparseDR реализована с использованием C++ and Vulkan и не использует автоматическое
    % дифференцирование. Градиенты аккумулируются в массив of floats, по размеру равный
    % числу обновляемых дистанций. В шейдере при расчёте цвета пикселя для 16 семплов
    % хранится информация о вокселях, в которые они попали, и каждые 16 семплов (или после последнего)
    % градиенты добавляются в массив.

    % SparseDR опционально использует дополнительный шейдер, который семплирует только
    % пиксели, содержащие границы, и оценивает только граничный интеграл, без необходимости
    % в расчёте цвета. Это адаптивное
    % семплирование границы позволяет делать более дешёвые семплы и получить более
    % точные градиенты для меньшего relaxed epsilon, reducing bias.

    The key distinction of the method underlying SparseDR lies in the transition from an
    SDF grid to a sparse brick set. In our case, each brick has a fixed size of 4×4×4 voxels.
    For the SBS, a BVH tree is constructed, with each leaf node storing a single brick.
    In addition to sphere tracing, alternative ray–SDF intersection methods have been
    implemented: Newton and analytic, specifically designed to find intersections inside
    the voxel. A ray first traverses the BVH; if an intersection with a leaf node is found,
    it then intersects the voxels of the brick. The ray proceeds through each brick along
    its path until the first intersection with a surface is reached.

    The alternative ray–SDF intersection methods also support searching for relaxed
    boundary points. According to [reference], a point belongs to the relaxed boundary
    if the SDF value at that point is below a certain threshold called the relaxed epsilon,
    and the SDF derivative along the ray reaches its local minimum. The Newton and analytic
    methods are based on the fact that inside a voxel, the SDF along the ray can be
    represented as a cubic polynomial. Thus, within the voxel, a potential relaxed boundary
    point can be found as the root of a quadratic equation, after which it is sufficient
    to verify that the SDF value at this point is less than the relaxed epsilon. The case
    when the local minimum occurs on the boundary between voxels or bricks is handled
    separately.

    SparseDR is implemented in C++ and Vulkan and does not use automatic differentiation.
    Gradients are accumulated in a float array whose size equals the number of updated
    distances. In the shader, when computing the color of a pixel for 16 samples,
    information about the voxels hit by the samples is stored; after every 16 samples
    (or after the last one), the gradients are added to the array.
    SparseDR optionally uses an additional shader that samples only pixels containing
    boundaries and evaluates only the boundary integral, without the need for color
    computation. This adaptive boundary sampling allows cheaper samples and yields more
    accurate gradients for smaller relaxed epsilon values, thereby reducing bias.

\subsection{Redistancing}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth,keepaspectratio]{figures/redistancing.eps}
    \caption{Comparison of the redistancing algorithm (on the left) with the accelerated version.
             Updating only the bricks with a surface is sufficient to get correct relaxed
             boundary points, as the brick size is larger than the relaxed epsilon.}
    \label{fig:redist}
\end{figure}

    % Для дифференцируемого рендеринга SBS в SparseDR реализовано две версии редистансинга.
    % Первая версия является адаптацией параллельной версии fast sweeping method [link]
    % для SBS. Для неё ребовалось решить проблему обновления дистанций
    % через пространство без кирпичей. Представьте кирпич без соседей, в котором нет поверхности.
    % Следуя алгоритму редистансинга, дистанции в нём будут проинициализированы некоторой
    % константой и затем никогда не обновятся. В случае дифференцируемого рендеринга
    % таких экстремальных случаев нет, но возможны ситуации, когда дистанции в брике
    % имеют большие абсолютные значения, чем должны, так как не учтены дистанции
    % брика неподалёку. Для решения этой проблемы был добавлен шаг экстраполяции значений
    % между гранями бриков. Для каждой грани брика без непосредственного соседа
    % находятся ближайшие соседи, у них выбирается одна грань, из которой будут
    % экстраполироваться значения. Соседи выбираются один раз, затем после каждого
    % шага of fast sweeping method значения экстраполируются с учётом расстояния
    % между значениями сетки. Из экстраполированного значения и предыдущего выбирается
    % минимальное по модулю. Чтобы распространить обновлённые дистанции, последним
    % шагом всегда идёт fast sweeping method.

    % Однако использование SBS instead of grid и метода Ньютона для поиска пересечения
    % inside the voxel instead of sphere tracing позволило исследовать возможности
    % для оптимизации редистансинга, результатом которых стала ускоренная версия,
    % используемая во всех экспериментах. Первая идея заключается в использовании
    % пересечения методом Ньютона в свою пользу. Так как луч проходит каждый воксель
    % на своём пути, он не зависит от значений дистанций в вокселях без границы.
    % поэтому для получения точного пересечения с поверхностью и точек релаксированной
    % границы достаточно применять редистансинг только в бриках с поверхностью.
    % Вторая идея заключается в предположении о том, что в бриках с поверхностью
    % для пересчёта дистанций достаточно учитывать только ту поверхность, что хранится
    % в этом брике, и не распространять дистанции между бриками. Это предположение
    % подтвердилось частично, так как в редистансинге на этапе инициализации происходит
    % пересчёт дистанций, задающих поверхность, и здесь важно получить наиболее точные
    % значения. Однако после инициализации достаточно проводить редистансинг локально
    % внутри бриков. На рис. Nn показан график MSE для итераций оптимизации модели
    % бюста Nefertiti с использованием обеих версий редистансинга. Ускоренная версия
    % не портит качество реконструкции и не мешает сходимости к референсу. After the
    % sparsification step применяется первая версия редистансинга, которая рассчитывает
    % все дистанции перед сохранением чекпоинта, чтобы модель являлась корректной SDF.

    For differentiable rendering of SBS in SparseDR, two versions of redistancing have
    been implemented. The first, full version, is an adaptation of the parallel fast sweeping
    method for SBS, which is used to acquire the correct SDF. In this version, it was
    necessary to address the problem of distance updates across empty space between bricks.
    Consider a brick without neighbors and without any surface inside it. Following the
    redistancing algorithm, the distances within it will be initialized with a constant
    value and will never be updated. In differentiable rendering, such extreme cases do
    not occur, but situations may arise where the distances within a brick have larger
    absolute values than they should, since adjacent bricks are not taken into account.
    To solve this issue, an extrapolation step between brick faces was introduced.
    For each face of a brick without a direct neighbor, the nearest neighbor bricks
    are found, and one of their faces is selected for extrapolating the values. These
    neighbors are determined once, and after each fast sweeping step, values are extrapolated
    considering the grid spacing. From the extrapolated and previous values, the one with
    the smallest absolute value is chosen. To propagate the updated distances, the fast
    sweeping method is always applied as the final step of this algorithm.

    However, using SBS instead of a grid and Newton’s method for intersection search
    inside the voxel instead of sphere tracing opened opportunities for optimization of
    the redistancing procedure. These resulted in an accelerated version, which is used
    after each iteration. The first idea is to exploit the properties of intersection
    based on the Newton method. Since each ray traverses all voxels along its path, it
    does not depend on exact distance values in voxels that do not contain boundaries. Therefore,
    to obtain accurate surface intersections and relaxed boundary points, it is sufficient
    to apply redistancing only for surface bricks. The second idea assumes that in surface
    bricks it is enough to compute distances considering only the surface stored within
    the same brick, without propagating distance values between bricks. This assumption
    was only partially confirmed, since during the initialization stage, redistancing
    recalculates distances defining the surface, and they must be as accurate as possible.
    However, after initialization, redistancing localized within individual bricks is sufficient.
    Figure Nn shows the MSE plot for optimization iterations of the Nefertiti bust model
    using both redistancing versions. The accelerated version neither degrades reconstruction
    quality nor affects convergence to the reference.

\subsection{Sparsification and Upsampling}

    % Sparsification step выполняется перед upsampling, во время него сохраняются все
    % брики, содержащие поверхность, а также все брики в радиусе 1 от них, включая
    % диагональные. Если какой-либо
    % из соседних бриков отсутствует, то он добавляется здесь. Этот шаг необходим в случае,
    % когда восстанавливаемый объект содержит детали настолько мелкие, что после upsampling
    % брики, в которых должна находиться их реконструкция, отсутствуют. Таким образом,
    % данный шаг не только отвечает за уменьшение размера модели, но и устраняет
    % потенциальное ограничение в сравнении с базовым методом.
    % Upsampling step увеличивает разрешение оставшихся бриков в два раза, получая из
    % одного брика восемь. Новые дистанции рассчитываются с помощью трилинейной
    % интерполяции.

    The sparsification step is performed before upsampling. During this stage, all bricks
    containing the surface are preserved, as well as all bricks within a radius of 1
    voxel from them, including diagonal neighbors. If any of the adjacent bricks are
    missing, they are added at this stage. This is necessary in cases where the
    reconstructed object contains fine details, so that the bricks where these details'
    reconstruction should reside would otherwise be absent. Thus, this step not only
    contributes to reducing the model size, but also eliminates a potential limitation
    compared to the baseline method.
    After the sparsification step, the full version of redistancing is applied to
    recompute all distances before upsampling or saving the resulting SBS, ensuring
    that the model represents a valid SDF.
    The upsampling step doubles the resolution of the remaining bricks, generating eight
    new bricks from each original one. The new distance values are computed using trilinear
    interpolation.




\section{Experiments}

    % Эксперименты с базовым методом
    % проводились с использованием [ссылка], где представлена его официальная реализация.
    % Для базового метода использовались гиперпараметры, указанные в статье (ссылка),
    % остальные параметры взяты из конфигурационного файла
    % "turbo.json", изменению подверглись число ракурсов, размер батча и шаги, на которых
    % проводился upsampling. Для
    % сходства экспериментов была использована одинаковая конфигурация источников света:
    % два направленных источника с направлениями (1,1,1) и (-1,-1,-1) и ambient light. 
    % По этой же причине для эталонной реализации были оставлены только первичные лучи
    % и реконструкция проводилась только для геометрии.
    
    % Эксперименты проводились на 6 моделях, реконструкция велась с 16 ракурсов, получаемых
    % алгоритмом из (ссылка) равномерно по сфере вокруг сцены, размер
    % батча: 4 ракурса. Размеры изображений: 1024x1024. Начальное приближение -- dense grid
    % with a sphere, размер 32x32x32 voxels. Полный процеcc оптимизации занимает
    % 1000 шагов, upsampling применяется на шагах 200,400,600,700,800,900.
    % Hardware configuration: вычисления производились on AMD Ryzen 9 7950X CPU and
    % Nvidia GeForce RTX 4090.

    Experiments with the baseline method were conducted using [https://github.com/zichenwang01/relaxed-boundary/],
    which provides its official implementation. The baseline method employed the hyperparameters
    specified in the paper [reference], while the remaining parameters were taken from
    the configuration file “turbo.json”. The only modifications concerned the number of
    viewpoints, the batch size, and the steps at which upsampling was performed. For
    consistency across experiments, an identical lighting setup was used: two directional
    light sources with directions $(1,1,1)$ and $(-1,-1,-1)$, along with ambient light.
    The experiments were carried out on six models. Reconstruction used 16 viewpoints
    uniformly distributed over a sphere around the scene, generated by the algorithm
    from [reference]. The batch size is 4 viewpoints, image resolution is 1024×1024.
    The full optimization process comprised 1000 steps, with upsampling applied at steps
    200, 400, 600, 700, 800, and 900. Computations were performed on an AMD Ryzen 9 7950X CPU
    and an NVIDIA GeForce RTX 4090 GPU.

    % На рис. N показано среднее по всем моделям время реконструкции for each stage between upsampling
    % steps для SparseDR и базового метода. Они обозначены размером SDF grid в вокселях соответствующего уровня
    % детализации. Batch rendering is a consecutive отрисовка всех ракурсов на текущем
    % батче.

    % На рис. N+1 показано среднее по ракурсам качество реконструкции для SparseDR и
    % базового метода.

    % И наконец, на рис. N+2 показан размер моделей для SparseDR и базового метода,
    % полученных после каждого upsampling step. Для базового метода указан размер of grid,
    % для SparseDR -- the size of SBS and the size of its BVH. Результаты показывают,
    % что рост размера SBS на порядок меньше, чем у SDF grid.

\section{Conclusion}

    In this work, we present SparseDR, a system for 3D reconstruction based on the method
    of differentiable rendering for a sparse SDF representation. Using [reference] as a
    baseline, we leverage the advantages of SBS and modify all stages of the algorithm.
    As a result, SparseDR achieves performance and reconstruction quality comparable to
    the original approach while reducing memory consumption by an order of magnitude.
    Future work will focus on upgrading SparseDR to a full-fledged path tracer and
    addressing the challenges that complicate the practical use of differentiable rendering,
    in particular the need for precise camera parameter information.

    % В данной работе была представлена SparseDR, система для 3D реконструкции,
    % основанная на методе дифференцируемого рендеринга для разреженного
    % SDF представления. Используя работу (ссылка) as baseline, мы используем преимущества
    % SBS и модифицируем все этапы алгоритма. В результате получем скорость и качество,
    % сравнимое с оригиналом, при этом на порядок снижая потребление памяти.

    % Дальнейшая работа будет направлена на реализацию полноценного path tracer pipeline,
    % исследование способов of gradient bias reduction, pushing further the quality of the
    % reconstruction, а также на решение проблем, усложняющих использование
    % дифференцируемого рендеринга на практике, в частности необходимость в информации
    % о параметрах камеры.
     

\subsection{Order of Sections}

Sections should be arranged in the following order \cite{bgf:Lixto}:
\begin{enumerate}
    \item Main content sections (numbered)
    \item Appendices (optional, numbered using capital letters)
    \item Ethical statement (optional, unnumbered)
    \item Acknowledgements (optional, unnumbered)
    \item Contribution statement (optional, unnumbered)
    \item References (required, unnumbered)
\end{enumerate}


%% The file named.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{named}
\bibliography{sparsedr}

\end{document}

